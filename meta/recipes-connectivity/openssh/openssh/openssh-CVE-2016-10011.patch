From 7e71ba71ec4d1ff09b0e5f9e1b1748900eeca306 Mon Sep 17 00:00:00 2001
From: "djm@openbsd.org" <djm@openbsd.org>
Date: Fri, 25 Nov 2016 23:24:45 +0000
Subject: [PATCH 2/3] openssh: CVE-2016-10011

commit 54d022026aae4f53fa74cc636e4a032d9689b64d upstream
git://anongit.mindrot.org/openssh.git

use sshbuf_allocate() to pre-allocate the buffer used for
loading keys. This avoids implicit realloc inside the buffer code, which
might theoretically leave fragments of the key on the heap. This doesn't
appear to happen in practice for normal sized keys, but was observed for
novelty oversize ones.

Pointed out by Jann Horn of Project Zero; ok markus@

Upstream-ID: d620e1d46a29fdea56aeadeda120879eddc60ab1

Upstream-Status: Backport
CVE: CVE-2016-10011

Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 authfile.c | 16 ++++++++++++++--
 sshbuf.c   | 44 +++++++++++++++++++++++++++++++++++++++++
 2 files changed, 58 insertions(+), 2 deletions(-)

diff --git a/authfile.c b/authfile.c
index f46b4e3..7411b68 100644
--- a/authfile.c
+++ b/authfile.c
@@ -1,4 +1,4 @@
-/* $OpenBSD: authfile.c,v 1.121 2016/04/09 12:39:30 djm Exp $ */
+/* $OpenBSD: authfile.c,v 1.122 2016/11/25 23:24:45 djm Exp $ */
 /*
  * Copyright (c) 2000, 2013 Markus Friedl.  All rights reserved.
  *
@@ -100,13 +100,25 @@ sshkey_load_file(int fd, struct sshbuf *blob)
 	u_char buf[1024];
 	size_t len;
 	struct stat st;
-	int r;
+	int r, dontmax = 0;
 
 	if (fstat(fd, &st) < 0)
 		return SSH_ERR_SYSTEM_ERROR;
 	if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&
 	    st.st_size > MAX_KEY_FILE_SIZE)
 		return SSH_ERR_INVALID_FORMAT;
+	/*
+	 * Pre-allocate the buffer used for the key contents and clamp its
+	 * maximum size. This ensures that key contents are never leaked via
+	 * implicit realloc() in the sshbuf code.
+	 */
+	if ((st.st_mode & S_IFREG) == 0 || st.st_size <= 0) {
+		st.st_size = 64*1024; /* 64k should be enough for anyone :) */
+		dontmax = 1;
+	}
+	if ((r = sshbuf_allocate(blob, st.st_size)) != 0 ||
+	    (dontmax && (r = sshbuf_set_max_size(blob, st.st_size)) != 0))
+		return r;
 	for (;;) {
 		if ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {
 			if (errno == EPIPE)
--- a/sshbuf.c
+++ b/sshbuf.c
@@ -316,6 +316,50 @@ sshbuf_check_reserve(const struct sshbuf
 }
 
 int
+sshbuf_allocate(struct sshbuf *buf, size_t len)
+{
+	size_t rlen, need;
+	u_char *dp;
+	int r;
+
+	SSHBUF_DBG(("allocate buf = %p len = %zu", buf, len));
+	if ((r = sshbuf_check_reserve(buf, len)) != 0)
+		return r;
+
+	/*
+	 * If the requested allocation appended would push us past max_size
+	 * then pack the buffer, zeroing buf->off.
+	 */
+	sshbuf_maybe_pack(buf, buf->size + len > buf->max_size);
+	SSHBUF_TELL("allocate");
+	if (len + buf->size <= buf->alloc)
+		return 0; /* already have it. */
+
+	/*
+	 * Prefer to alloc in SSHBUF_SIZE_INC units, but
+	 * allocate less if doing so would overflow max_size.
+	 */ 
+	need = len + buf->size - buf->alloc;
+	rlen = roundup(buf->alloc + need, SSHBUF_SIZE_INC);
+	SSHBUF_DBG(("need %zu initial rlen %zu", need, rlen));
+	if (rlen > buf->max_size)
+		rlen = buf->alloc + need;
+	SSHBUF_DBG(("adjusted rlen %zu", rlen));
+	if ((dp = realloc(buf->d, rlen)) == NULL) {
+		SSHBUF_DBG(("realloc fail"));
+		return SSH_ERR_ALLOC_FAIL;
+	}
+	buf->alloc = rlen;
+	buf->cd = buf->d = dp;
+	if ((r = sshbuf_check_reserve(buf, len)) < 0) {
+		/* shouldn't fail */
+		return r;
+	}
+	SSHBUF_TELL("done");
+	return 0;
+}
+
+int
 sshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)
 {
 	size_t rlen, need;
-- 
2.10.1

