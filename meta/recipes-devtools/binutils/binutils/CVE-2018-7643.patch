From d11ae95ea3403559f052903ab053f43ad7821e37 Mon Sep 17 00:00:00 2001
From: Nick Clifton <nickc@redhat.com>
Date: Thu, 1 Mar 2018 16:14:08 +0000
Subject: [PATCH] Prevent illegal memory accesses triggerd by intger overflow
 when parsing corrupt DWARF information on a 32-bit host.

	PR 22905
	* dwarf.c (display_debug_ranges): Check that the offset loaded
	from the range_entry structure is valid.

(cherry picked from commit d11ae95ea3403559f052903ab053f43ad7821e37)

CVE: CVE-2018-7643
Upstream-Status: Backport(master)

Signed-off-by: Yue Tao <yue.tao@windriver.com>
---
 binutils/ChangeLog |    6 ++++++
 binutils/dwarf.c   |   15 +++++++++++++++
 2 files changed, 21 insertions(+)

diff --git a/binutils/ChangeLog b/binutils/ChangeLog
index d9db858..067dd95 100644
--- a/binutils/ChangeLog
+++ b/binutils/ChangeLog
@@ -1,3 +1,9 @@
+2018-03-01  Nick Clifton  <nickc@redhat.com>
+
+	PR 22905
+	* dwarf.c (display_debug_ranges): Check that the offset loaded
+	from the range_entry structure is valid.
+
 2018-02-01  Alan Modra  <amodra@gmail.com>
 
 	PR 22769
diff --git a/binutils/dwarf.c b/binutils/dwarf.c
index 6aca9b7..17896e6 100644
--- a/binutils/dwarf.c
+++ b/binutils/dwarf.c
@@ -342,6 +342,9 @@ read_uleb128 (unsigned char * data,
     }								\
   while (0)
 
+/* Read AMOUNT bytes from PTR and store them in VAL as an unsigned value.
+   Checks to make sure that the read will not reach or pass END
+   and that VAL is big enough to hold AMOUNT bytes.  */
 #define SAFE_BYTE_GET(VAL, PTR, AMOUNT, END)	\
   do						\
     {						\
@@ -366,6 +369,7 @@ read_uleb128 (unsigned char * data,
     }						\
   while (0)
 
+/* Like SAFE_BYTE_GET, but also increments PTR by AMOUNT.  */
 #define SAFE_BYTE_GET_AND_INC(VAL, PTR, AMOUNT, END)	\
   do							\
     {							\
@@ -374,6 +378,7 @@ read_uleb128 (unsigned char * data,
     }							\
   while (0)
 
+/* Like SAFE_BYTE_GET, but reads a signed value.  */
 #define SAFE_SIGNED_BYTE_GET(VAL, PTR, AMOUNT, END)	\
   do							\
     {							\
@@ -392,6 +397,7 @@ read_uleb128 (unsigned char * data,
     }							\
   while (0)
 
+/* Like SAFE_SIGNED_BYTE_GET, but also increments PTR by AMOUNT.  */
 #define SAFE_SIGNED_BYTE_GET_AND_INC(VAL, PTR, AMOUNT, END)	\
   do								\
     {								\
@@ -5257,6 +5263,13 @@ display_debug_ranges (struct dwarf_secti
 	  continue;
 	}
 
+      if (next < section_begin || next >= finish)
+	{
+	  warn (_("Corrupt offset (%#8.8lx) in range entry %u\n"),
+		(unsigned long) offset, i);
+	  continue;
+	}
+
       if (dwarf_check != 0 && i > 0)
 	{
 	  if (start < next)
@@ -5272,6 +5285,7 @@ display_debug_ranges (struct dwarf_secti
 		    (unsigned long) (next - section_begin), section->name);
 	    }
 	}
+
       start = next;
       last_start = next;
 
@@ -5285,6 +5299,7 @@ display_debug_ranges (struct dwarf_secti
 	    break;
 	  SAFE_SIGNED_BYTE_GET_AND_INC (end, start, pointer_size, finish);
 
+
 	  printf ("    %8.8lx ", offset);
 
 	  if (begin == 0 && end == 0)
-- 
1.7.9.5

