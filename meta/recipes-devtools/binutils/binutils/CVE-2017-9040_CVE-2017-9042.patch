From 6e2a222b314d1c2e238c5ad405714d798143e07f Mon Sep 17 00:00:00 2001
From: Nick Clifton <nickc@redhat.com>
Date: Thu, 13 Apr 2017 16:06:30 +0100
Subject: readelf: fix out of range subtraction, seg fault from a NULL pointer
 and memory exhaustion, all from parsing corrupt binaries.

	PR binutils/21379
	* readelf.c (process_dynamic_section): Detect over large section
	offsets in the DT_SYMTAB entry.

	PR binutils/21345
	* readelf.c (process_mips_specific): Catch an unfeasible memory
	allocation before it happens and print a suitable error message.

(cherry picked from commit 7296a62a2a237f6b1ad8db8c38b090e9f592c8cf)

CVE: CVE-2017-9040 CVE-2017-9042
Upstream-Status: Backport[master]
Signed-off-by: Yuanjie Huang <yuanjie.huang@windriver.com>
---
 binutils/ChangeLog |  6 ++++++
 binutils/readelf.c | 15 +++++++++++++++
 2 files changed, 21 insertions(+)

diff --git a/binutils/ChangeLog b/binutils/ChangeLog
index 464c40273c..b857197a3e 100644
--- a/binutils/ChangeLog
+++ b/binutils/ChangeLog
@@ -1,3 +1,9 @@
+2017-04-13  Nick Clifton  <nickc@redhat.com>
+
+	PR binutils/21379
+	* readelf.c (process_dynamic_section): Detect over large section
+	offsets in the DT_SYMTAB entry.
+
 2017-04-03  Nick Clifton  <nickc@redhat.com>
 
 	PR binutils/21345
diff --git a/binutils/readelf.c b/binutils/readelf.c
index 0b0208dec7..f7256552cf 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -9080,6 +9080,12 @@ process_dynamic_section (FILE * file)
 	     processing that.  This is overkill, I know, but it
 	     should work.  */
 	  section.sh_offset = offset_from_vma (file, entry->d_un.d_val, 0);
+	  if ((bfd_size_type) section.sh_offset > current_file_size)
+	    {
+	      /* See PR 21379 for a reproducer.  */
+	      error (_("Invalid DT_SYMTAB entry: %lx"), (long) section.sh_offset);
+	      return 0;
+	    }
 
 	  if (archive_file_offset != 0)
 	    section.sh_size = archive_file_size - section.sh_offset;
@@ -14883,6 +14889,15 @@ process_mips_specific (FILE * file)
 	  return 0;
 	}
 
+      /* PR 21345 - print a slightly more helpful error message
+	 if we are sure that the cmalloc will fail.  */
+      if (conflictsno * sizeof (* iconf) > current_file_size)
+	{
+	  error (_("Overlarge number of conflicts detected: %lx\n"),
+		 (long) conflictsno);
+	  return 0;
+	}
+
       iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));
       if (iconf == NULL)
 	{
-- 
2.11.0

